datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
}

model User {
  id                    String                  @id @default(uuid()) @db.Uuid
  name                  String?
  email                 String?
  password              String?
  role                  OrganizationRole?       @default(MEMBER)
  emailVerified         DateTime?
  isTwoFactorEnabled    Boolean                 @default(false)
  twoFactorConfirmation TwoFactorConfirmation[]
  image                 String?

  // Organization context
  hasCompletedOnboarding Boolean       @default(false)
  organizationId         String?       @db.Uuid
  organization           Organization? @relation("UserOrganization", fields: [organizationId], references: [id], onDelete: SetNull)

  accounts                Account[]
  events                  Events[]
  participations          EventParticipation[]
  organizationMemberships OrganizationMember[]
  sentInvites             PendingInvite[]      @relation("InvitedBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([email])
}

model Account {
  id                String  @id @default(uuid()) @db.Uuid
  userId            String  @db.Uuid()
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id        String   @id @default(uuid()) @db.Uuid
  email     String
  token     String   @unique
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([email, token])
}

model PasswordResetToken {
  id        String   @id @default(uuid()) @db.Uuid
  email     String
  token     String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([email, token])
}

model TwoFactorToken {
  id        String   @id @default(uuid()) @db.Uuid
  email     String
  token     String
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(uuid()) @db.Uuid
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId])
}

enum EventVisibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

enum EventType {
  ONLINE
  OFFLINE
  HYBRID
}

model Events {
  id            String   @id @default(uuid()) @db.Uuid
  title         String
  description   String
  location      String
  image         String?
  startDateTime DateTime @default(now())
  endDateTime   DateTime @default(now())
  price         String?
  isFree        Boolean  @default(false)
  url           String?

  // Event metadata
  visibility    EventVisibility @default(PUBLIC)
  eventType     EventType       @default(OFFLINE)
  maxAttendees  Int?
  attendeeCount Int             @default(0)

  // Relationships
  organizationId String?              @db.Uuid
  categoryId     String               @db.Uuid
  category       Category             @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  organization   Organization?        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  participations EventParticipation[]
  userId         String?              @db.Uuid
  User           User?                @relation(fields: [userId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizationId])
  @@index([categoryId])
  @@index([startDateTime])
  @@index([visibility])
}

model Category {
  id     String   @id @default(uuid()) @db.Uuid
  label  String
  events Events[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([label])
}

enum OrganizationSize {
  STARTUP
  SME
  ENTERPRISE
}

model Organization {
  id          String            @id @default(uuid()) @db.Uuid
  name        String
  industryId  String            @db.Uuid
  industry    Industry          @relation(fields: [industryId], references: [id], onDelete: Cascade)
  description String?
  website     String?
  logo        String?
  location    String?
  size        OrganizationSize? @default(STARTUP)
  isVerified  Boolean           @default(false)
  createdBy   String            @db.Uuid

  members        OrganizationMember[]
  events         Events[]
  participations EventParticipation[]
  users          User[]               @relation("UserOrganization")
  pendingInvites PendingInvite[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([industryId])
  @@index([createdBy])
}

model OrganizationMember {
  id             String           @id @default(uuid()) @db.Uuid
  userId         String           @db.Uuid
  organizationId String           @db.Uuid
  role           OrganizationRole @default(MEMBER)

  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, organizationId])
}

enum ParticipationStatus {
  REGISTERED
  ATTENDED
  CANCELLED
  WAITLISTED
}

// Renamed from Orders to better reflect B2B participation model
model EventParticipation {
  id String @id @default(uuid()) @db.Uuid

  // Event reference
  eventId String @db.Uuid
  event   Events @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Organization participation (primary for B2B)
  organizationId String?       @db.Uuid
  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  // User who registered (can be on behalf of organization)
  userId String @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Participation details
  status ParticipationStatus @default(REGISTERED)

  // Payment info (for paid events)
  stripeId    String? @unique
  totalAmount String?
  isPaid      Boolean @default(false)

  // Metadata
  registeredAt DateTime  @default(now())
  attendedAt   DateTime?
  cancelledAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Ensure one participation per user per event
  @@unique([eventId, userId])
  // For B2B: one participation per org per event (when org is specified)
  @@unique([eventId, organizationId])
  @@index([userId])
  @@index([organizationId])
  @@index([status])
}

model Industry {
  id           String         @id @default(uuid()) @db.Uuid
  label        String
  organization Organization[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([label])
}

enum InviteStatus {
  PENDING
  SENT
  ACCEPTED
  FAILED
  EXPIRED
}

model PendingInvite {
  id             String           @id @default(uuid()) @db.Uuid
  organizationId String           @db.Uuid
  email          String
  role           OrganizationRole
  invitedBy      String           @db.Uuid
  token          String           @unique
  status         InviteStatus     @default(PENDING)
  attempts       Int              @default(0)
  maxAttempts    Int              @default(3)
  lastAttempt    DateTime?
  error          String?
  expiresAt      DateTime
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  inviter      User         @relation("InvitedBy", fields: [invitedBy], references: [id])

  @@index([status, createdAt])
  @@index([token])
  @@index([email])
}

enum JobType {
  SEND_INVITE_EMAIL
  SEND_NOTIFICATION
  SEND_EVENT_REMINDER
  GENERATE_REPORT
  CLEANUP_DATA
}

enum JobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

model JobQueue {
  id          String    @id @default(uuid()) @db.Uuid
  type        JobType
  payload     Json
  status      JobStatus @default(PENDING)
  attempts    Int       @default(0)
  maxAttempts Int       @default(3)
  scheduledAt DateTime  @default(now())
  processedAt DateTime?
  error       String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([status, scheduledAt])
  @@index([type, status])
}
